<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title></title>
    <meta charset="utf-8" />
    <style type="text/css">
        body {
            margin: 0;
            padding: 0;
        }

        .wrap {
            width: 366px;
            margin: 0 auto;
        }

        .wrap div {
            float: left;
            width: 100px;
            height: 80px;
            margin: 10px;
            border: 1px solid #ccc;
            cursor: pointer;
            background-clip: padding-box;

        }

        .active {
            border: 1px dashed #000;
        }
            
    </style>
    <script>
        
        function Drag(sClass) {

            var sClass = sClass || null;
            var _this = this;

            var oWrap = document.querySelector(sClass);

            this.aDiv = oWrap.getElementsByTagName('div');

            this.aPos = [];
            this.len = this.aDiv.length;
            this.minIndex = 2;

            this.changeLayout();
        }

        Drag.prototype = {
            //获取随机颜色
            getRandomColor: function() {
                return '#' + ('00000' + (Math.random() * 0x1000000 << 0).toString(16)).slice(-6);
            },
            //拖拽函数
            setDrag: function (obj) {

                var oNear = null;
                var _this = this;

                obj.onmousedown = function (e) {
                    var l = e.clientX - obj.offsetLeft;
                    var t = e.clientY - obj.offsetTop;

                    document.onmousemove = function (e) {

                        obj.style.zIndex = _this.minIndex++;
                        obj.style.left = e.clientX - l + 'px';
                        obj.style.top = e.clientY - t + 'px';

                        for (i = 0; i < _this.len; i++) {
                            _this.aDiv[i].className = '';
                        }
                        //添加className 表示可交互状态
                        oNear = _this.findNearest(obj);
                        if (oNear) {
                            oNear.className = 'active';
                        }
                    };

                    document.onmouseup = function () {
                        document.onmousemove = null;
                        document.onmouseup = null;

                        //释放鼠标 存在最近距离对象时进行交换
                        if (oNear) {
                            //利用aPos数组中存储的位置信息进行交换
                            _this.startMove(obj, _this.aPos[oNear.index]);
                            _this.startMove(oNear, _this.aPos[obj.index]);
                            oNear.className = '';

                            //交换index
                            obj.index += oNear.index;
                            oNear.index = obj.index - oNear.index;
                            obj.index -= oNear.index;

                            //两者交换时保持层级最大
                            oNear.style.zIndex = _this.minIndex++;
                            obj.style.zIndex = _this.minIndex++;

                        } else {
                            //不存在则回到初始位置
                            _this.startMove(obj, aPos[obj.index]);
                        }
                    };
                    clearInterval(obj.timer);
                    return false;
                };
            },
            //碰撞检测 碰撞返回true
            crashTest: function (obj1, obj2) {
                var tLine1 = obj1.offsetTop;
                var rLine1 = obj1.offsetLeft + obj1.offsetWidth;
                var bLine1 = obj1.offsetTop + obj1.offsetHeight;
                var lLine1 = obj1.offsetLeft;

                var tLine2 = obj2.offsetTop;
                var rLine2 = obj2.offsetLeft + obj2.offsetWidth;
                var bLine2 = obj2.offsetTop + obj2.offsetHeight;
                var lLine2 = obj2.offsetLeft;

                if (rLine1 < lLine2 || bLine1 < tLine2 || lLine1 > rLine2 || tLine1 > bLine2) {
                    return false;
                }
                return true;
            },
            //勾股定理获得直线距离
            getDistance: function (obj1, obj2) {
                var a = obj1.offsetLeft - obj2.offsetLeft;
                var b = obj1.offsetTop - obj2.offsetTop;
                return Math.sqrt(a * a + b * b);
            },
            //获得碰撞且有最近距离的对象
            findNearest: function (obj) {
                var min = 99999;
                var index = -1;
                for (i = 0; i < this.len; i++) {
                    //当aDiv[i]为当前对象时跳过
                    if (obj == this.aDiv[i])
                        continue;
                    //循环比较得到最小值和索引
                    if (this.crashTest(obj, this.aDiv[i])) {
                        var dis = this.getDistance(obj, this.aDiv[i]);
                        if (dis < min) {
                            min = dis;
                            index = i;
                        }
                    }
                }
                if (index !== -1) {
                    return this.aDiv[index];
                }
                return null;
            },
                //运动框架
            startMove: function (obj, json, fn) {
                var _this = this;

                clearInterval(obj.timer);

                obj.timer = setInterval(function () {

                    var bStop = true;

                    for (var attr in json) {

                        var iCur = 0;

                        if (attr == 'opacity') {
                            iCur = parseInt(parseFloat(_this.getStyle(obj, attr)) * 100);
                        } else {
                            iCur = parseInt(_this.getStyle(obj, attr));
                        }

                        var iSpeed = (json[attr] - iCur) / 6;
                        iSpeed = iSpeed > 0 ? Math.ceil(iSpeed) : Math.floor(iSpeed);

                        if (iCur != json[attr]) {
                            bStop = false;
                        }

                        if (attr == 'opacity') {
                            obj.style.filter = 'alpha(opacity:' + (iCur + iSpeed) + ')';
                            obj.style.opacity = (iCur + iSpeed) / 100;
                        } else {
                            obj.style[attr] = iCur + iSpeed + 'px';
                        }
                    }

                    if (bStop) {
                        clearInterval(obj.timer);
                        if (fn) {
                            fn();
                        }
                    }
                }, 30);
            },
                //行间样式
            getStyle: function (obj, attr) {
                return obj.currentStyle ? obj.currentStyle[attr] : getComputedStyle(obj, null)[attr];
            },
                // 布局转换
            changeLayout: function () {
                var i = 0;

                for (i = 0; i < this.len; i++) {
                    //数组存储初始位置信息
                    this.aPos[i] = { left: this.aDiv[i].offsetLeft, top: this.aDiv[i].offsetTop };
                }
                for (i = 0; i < this.len; i++) {

                    this.aDiv[i].style.left = this.aPos[i].left + 'px';
                    this.aDiv[i].style.top = this.aPos[i].top + 'px';

                    this.aDiv[i].style.backgroundColor = this.getRandomColor();
                    this.aDiv[i].style.position = 'absolute';
                    this.aDiv[i].style.margin = '0';

                    this.aDiv[i].index = i;
                    this.setDrag(this.aDiv[i]);
                }
            }
        };

        window.onload = function () {

            new Drag('.wrap');
        };
    </script>
</head>
<body>
    <div class="wrap">
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
    </div>
</body>
</html>
